function[vtkinfo] = readvtk_gmsh(filename)
% reads vtk file generated by gmsh
% - file contains data for unstructured mesh
% author: Bryan Howell, Ph.D. (3/23/2016)
% reference: http://www.vtk.org/wp-content/uploads/2015/04/file-formats.pdf

%% open file 
% check for errors

% make sure file is opened
fid=fopen(filename,'r');
if(fid==-1)
    error('The file could not be opened.');
end

% file version should be "# vtk DataFile Version X.X"
file_ver=fgets(fid);% -1 if eof
if( ~strcmp(file_ver(3:5),'vtk') )
    error('The file is not a valid VTK one.');    
end

%% read through header
% head ends when ASCII or BINARY is encountered

header=true;
while(header)
    strtmp=fgets(fid);
    if(strcmp(strtmp(1:5),'ASCII')||strcmp(strtmp(1:6),'BINARY'))
        header=false; 
    end
end

%% read header

% make sure the data is for an unstructured grid 
strtmp=fgets(fid);
str=sscanf(strtmp,'%*s %s');
if(~strcmp(str,'UNSTRUCTURED_GRID'))
    error('The dataset is not for an unstructured grid.');
end

% read heading for points section
strtmp=fgets(fid);
numnodes=sscanf(strtmp,'%*s %d %*s',1);

%% read points
% - data precision is listed as double but floating works
[Apre,count]=fscanf(fid,'%f %f %f',3*numnodes);
A=zeros(3,numnodes);
A(:)=Apre;
vtkinfo.nodes=A';
if(count~=3*numnodes)
    error('Points not read correctly.');
end
fgets(fid); % return line before next data type
fgets(fid); % blank line after section

%% read mesh information
% elements of mesh are referred to as cells

strtmp=fgets(fid);
% cellnums contains two numbers
% - 1st number is the number of cells
% - 2nd number is the total number of points for all cells
% (many points overlap)
cellnums=sscanf(strtmp,'%*s %d %d',[1,2]);

% cell data (points per each cell)
% - number of points per cell is variable
[celldata,count1]=fscanf(fid,'%f',cellnums(2));
if(count1~=cellnums(2))
    error('data was not read correctly');
end
fgets(fid); % return line
fgets(fid); % blank line
fgets(fid); % header for cell type

% cell type
% - integers classifying type of cell (see below)
[celltype,count2]=fscanf(fid,'%f',cellnums(1));
if(count2~=cellnums(1))
    error('data was not read correctly');
end

%% organize cell/mesh data
% TYPES:
% 1, linear points
% 21, quadratic lines
% 22, quadratic surfaces
% 24, quadratic volumes 

% find indices of ecah type
indx_1=find(celltype==1);
indx_21=find(celltype==21);
indx_22=find(celltype==22);
indx_24=find(celltype==24);

% number of each type of cell
n1=length(indx_1);
n21=length(indx_21);
n22=length(indx_22);
n24=length(indx_24);

% linear index where each type of cells starts
% - all data for all cells, which each have a variable number of points, is
% unwound into a single vector
io_1=1;
io_21=io_1+(celldata(io_1)+1)*n1;
io_22=io_21+(celldata(io_21)+1)*n21;
io_24=io_22+(celldata(io_22)+1)*n22;

if(n24==0) % 2D
    
    % points per type of cell (ppc)
    % ppc_1=celldata(io_1);
    ppc_21=celldata(io_21);
    ppc_22=celldata(io_22);

    % extract surface elements
    A21=zeros(ppc_21+1,n21);
    A21(:)=celldata(io_21:io_22-1);
    vtkinfo.bndele=A21(2:(ppc_21+1),:)'+1; % +1 for 1-n indexing

    % extract interior elements
    A22=zeros(ppc_22+1,n22);
    A22(:)=celldata(io_22:end);
    vtkinfo.volele=A22(2:(ppc_22+1),:)'+1; % +1 for 1-n indexing

else

    % points per type of cell (ppc)
    % ppc_1=celldata(io_1);
    ppc_22=celldata(io_22);
    ppc_24=celldata(io_24);

    % extract surface elements
    A22=zeros(ppc_22+1,n22);
    A22(:)=celldata(io_22:io_24-1);
    vtkinfo.bndele=A22(2:(ppc_22+1),:)'+1; % +1 for 1-n indexing
    
    % extract interior elements
    A24=zeros(ppc_24+1,n24);
    A24(:)=celldata(io_24:end);
    vtkinfo.volele=A24(2:(ppc_24+1),:)'+1; % +1 for 1-n indexing    
    
end


%% close file

fclose(fid);
